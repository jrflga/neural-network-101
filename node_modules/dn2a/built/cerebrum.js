"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Cerebrum = undefined;

var _lodash = require("lodash");

var _ = _interopRequireWildcard(_lodash);

var _mathjs = require("mathjs");

var m = _interopRequireWildcard(_mathjs);

var _alpha = require("./networks/alpha");

var _neuron = require("./neuron");

var _synapse = require("./synapse");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var Cerebrum = function Cerebrum(configuration) {
    this.configuration = configuration || {
        minds: [{
            name: "defaultMind",
            network: {
                generator: _alpha.NetworkAlpha,
                configuration: {
                    layerDimensions: [2, 4, 1],
                    learningMode: "continuous",
                    learningRate: 0.3,
                    momentumRate: 0.7,
                    maximumError: 0.005,
                    maximumEpoch: 1000,
                    dataRepository: {},
                    neuron: {
                        generator: _neuron.Neuron
                    },
                    synapse: {
                        generator: _synapse.Synapse
                    },
                    numbersPrecision: 32
                }
            },
            inputsFrom: ["cerebrum"]
        }],
        outputsFrom: ["defaultMind"]
    };

    if (!this.checkConfiguration()) {
        throw "Invalid Cerebrum Module Configuration";
    }
    this.configuration = this.transformConfiguration();

    this.minds = [];

    this.inputs = []; // inputs are objects with the pattern and the name of the recipient mind (because there could be more than one listening for inputs)

    this.outputs = []; // outputs are objects with the pattern and the name of the source mind (because there could be more than one producing outputs)

    m.config({
        number: "BigNumber",
        precision: this.configuration.numbersPrecision
    });

    _.forEach(this.configuration.minds, function (configuration) {
        this.buildMind(configuration);
    }.bind(this));
};

Cerebrum.prototype = {
    checkConfiguration: function checkConfiguration() {
        return true;
    },

    transformConfiguration: function transformConfiguration() {
        return this.configuration;
    },

    buildMind: function buildMind(configuration) {
        this.minds.push({
            name: configuration.name,
            network: new configuration.network.generator(configuration.network.configuration)
        });
    },

    trainMind: function trainMind(trainingPatterns, epochCallback, iterationCallback) {
        var mindName = arguments.length <= 3 || arguments[3] === undefined ? "defaultMind" : arguments[3];

        var mind = _.find(this.minds, {
            name: mindName
        }).network;
        mind.train(trainingPatterns, epochCallback, iterationCallback);
    },

    queryMind: function queryMind(queryingPatterns, epochCallback, iterationCallback) {
        var mindName = arguments.length <= 3 || arguments[3] === undefined ? "defaultMind" : arguments[3];

        var mind = _.find(this.minds, {
            name: mindName
        }).network;
        mind.query(queryingPatterns, epochCallback, iterationCallback);
    }
};

exports.Cerebrum = Cerebrum;
