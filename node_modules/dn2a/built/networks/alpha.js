"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NetworkAlpha = undefined;

var _lodash = require("lodash");

var _ = _interopRequireWildcard(_lodash);

var _mathjs = require("mathjs");

var m = _interopRequireWildcard(_mathjs);

var _neuron = require("../neuron");

var _synapse = require("../synapse");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var NetworkAlpha = function NetworkAlpha(configuration) {
    this.configuration = configuration || {
        layerDimensions: [2, 4, 1],
        learningMode: "continuous",
        learningRate: 0.3,
        momentumRate: 0.7,
        maximumError: 0.005,
        maximumEpoch: 1000,
        dataRepository: {},
        neuron: {
            generator: _neuron.Neuron
        },
        synapse: {
            generator: _synapse.Synapse
        },
        numbersPrecision: 32
    };

    if (!this.checkConfiguration()) {
        throw "Invalid NetworkAlpha Module Configuration";
    }
    this.configuration = this.transformConfiguration();

    this.dataRepository = this.configuration.dataRepository;

    this.neuronGenerator = this.configuration.neuron.generator({
        numbersPrecision: this.configuration.numbersPrecision
    });

    this.synapseGenerator = this.configuration.synapse.generator({
        numbersPrecision: this.configuration.numbersPrecision
    });

    m.config({
        number: "BigNumber",
        precision: this.configuration.numbersPrecision
    });

    this.generateNeurons();
    this.generateSynapses();
};

NetworkAlpha.prototype = {
    checkConfiguration: function checkConfiguration() {
        return true;
    },

    transformConfiguration: function transformConfiguration() {
        return this.configuration;
    },

    generateNeurons: function generateNeurons() {
        var neuronLayers = [];
        _.forEach(this.configuration.layerDimensions, function (layerDimension) {
            var layerNeurons = [];
            var neuronScope = neuronLayers.length === 0 ? "input" : neuronLayers.length < this.configuration.layerDimensions.length - 1 ? "hidden" : "output";
            _.times(layerDimension, function () {
                layerNeurons.push(this.generateNeuron(neuronScope));
            }.bind(this));
            if (neuronScope === "input" || neuronScope === "hidden") {
                layerNeurons.push(this.generateNeuron("bias"));
            }
            neuronLayers.push(layerNeurons);
        }.bind(this));
        this.dataRepository.neuronLayers = neuronLayers;
    },

    generateNeuron: function generateNeuron(scope) {
        var neuron = new this.neuronGenerator();
        var proxy = scope === "input" ? true : false;
        var fixed = scope === "bias" ? true : false;
        var output = m.bignumber(fixed ? 1 : 0);
        neuron.proxy = proxy;
        neuron.fixed = fixed;
        neuron.output = output;
        return neuron;
    },

    generateSynapses: function generateSynapses() {
        var previousLayerNeurons = [];
        _.forEach(this.dataRepository.neuronLayers, function (neuronLayer, neuronLayerIndex, neuronLayers) {
            var layerNeurons = neuronLayers[neuronLayerIndex];
            if (neuronLayerIndex > 0) {
                _.forEach(layerNeurons, function (layerNeuron, layerNeuronIndex, layerNeurons) {
                    if (!layerNeuron.fixed) {
                        _.forEach(previousLayerNeurons, function (previousLayerNeuron, previousLayerNeuronIndex, previousLayerNeurons) {
                            var synapse = this.generateSynapse();
                            synapse.incomingConnection = previousLayerNeuron;
                            synapse.outgoingConnection = layerNeuron;
                            previousLayerNeuron.addOutgoingConnection(synapse);
                            layerNeuron.addIncomingConnection(synapse);
                        }.bind(this));
                    }
                }.bind(this));
            }
            previousLayerNeurons = layerNeurons;
        }.bind(this));
    },

    generateSynapse: function generateSynapse() {
        var synapse = new this.synapseGenerator();
        return synapse;
    },

    setInputPattern: function setInputPattern(inputPattern) {
        _.forEach(this.dataRepository.neuronLayers[0], function (layerNeuron, layerNeuronIndex, layerNeurons) {
            if (!layerNeuron.fixed) {
                layerNeurons[layerNeuronIndex].output = m.bignumber(inputPattern[layerNeuronIndex]);
            }
        });
    },

    getInputPattern: function getInputPattern() {
        var inputPattern = [];
        _.forEach(this.dataRepository.neuronLayers[0], function (layerNeuron, layerNeuronIndex, layerNeurons) {
            // inputPattern[layerNeuronIndex] = m.number(layerNeurons[layerNeuronIndex].output);
            inputPattern[layerNeuronIndex] = layerNeurons[layerNeuronIndex].output;
        });
        return inputPattern;
    },

    setExpectedOutputPattern: function setExpectedOutputPattern(expectedOutputPattern) {
        _.forEach(this.dataRepository.neuronLayers[this.dataRepository.neuronLayers.length - 1], function (layerNeuron, layerNeuronIndex, layerNeurons) {
            layerNeurons[layerNeuronIndex].expectedOutput = m.bignumber(expectedOutputPattern[layerNeuronIndex]);
        });
    },

    getExpectedOutputPattern: function getExpectedOutputPattern() {
        var expectedOutputPattern = [];
        _.forEach(this.dataRepository.neuronLayers[this.dataRepository.neuronLayers.length - 1], function (layerNeuron, layerNeuronIndex, layerNeurons) {
            expectedOutputPattern[layerNeuronIndex] = m.number(layerNeuron.expectedOutput);
            // expectedOutputPattern[layerNeuronIndex] = layerNeuron.expectedOutput;
        });
        return expectedOutputPattern;
    },

    setOutputPattern: function setOutputPattern(outputPattern) {
        _.forEach(this.dataRepository.neuronLayers[this.dataRepository.neuronLayers.length - 1], function (layerNeuron, layerNeuronIndex, layerNeurons) {
            layerNeurons[layerNeuronIndex].output = m.bignumber(outputPattern[layerNeuronIndex]);
        });
    },

    getOutputPattern: function getOutputPattern() {
        var outputPattern = [];
        _.forEach(this.dataRepository.neuronLayers[this.dataRepository.neuronLayers.length - 1], function (layerNeuron, layerNeuronIndex, layerNeurons) {
            outputPattern[layerNeuronIndex] = m.number(layerNeuron.output);
            // outputPattern[layerNeuronIndex] = layerNeuron.output;
        });
        return outputPattern;
    },

    getOutputError: function getOutputError() {
        var outputError = // m.number(
        m.divide(_.reduce(this.dataRepository.neuronLayers[this.dataRepository.neuronLayers.length - 1], function (totalOutputError, layerNeuron) {
            return m.add(totalOutputError, m.square(layerNeuron.outputError));
        }, m.bignumber(0)), this.dataRepository.neuronLayers[this.dataRepository.neuronLayers.length - 1].length);
        // );
        return outputError;
    },

    calculateActivations: function calculateActivations() {
        _.forEach(this.dataRepository.neuronLayers, function (neuronLayer, neuronLayerIndex, neuronLayers) {
            var layerNeurons = neuronLayers[neuronLayerIndex];
            if (neuronLayerIndex > 0) {
                _.forEach(layerNeurons, function (layerNeuron, layerNeuronIndex, layerNeurons) {
                    if (!layerNeuron.fixed) {
                        _.forEach(layerNeuron.incomingConnections, function (synapse, synapseIndex, synapses) {
                            layerNeuron.inputSum = m.add(layerNeuron.inputSum, m.multiply(synapse.incomingConnection.output, synapse.weight));
                        });
                        layerNeuron.output = layerNeuron.transferFunction(layerNeuron.inputSum);
                        layerNeuron.outputError = m.subtract(layerNeuron.expectedOutput, layerNeuron.output);
                        layerNeuron.inputSum = 0;
                    }
                });
            }
        });
    },

    calculateDeltas: function calculateDeltas() {
        _.forEachRight(this.dataRepository.neuronLayers, function (neuronLayer, neuronLayerIndex, neuronLayers) {
            if (neuronLayerIndex > 0) {
                var layerNeurons = neuronLayers[neuronLayerIndex];
                if (neuronLayerIndex === this.dataRepository.neuronLayers.length - 1) {
                    _.forEach(layerNeurons, function (layerNeuron, layerNeuronIndex, layerNeurons) {
                        layerNeuron.delta = m.chain(layerNeuron.outputError).multiply(layerNeuron.output).multiply(m.subtract(m.bignumber(1), layerNeuron.output)).done();
                    });
                } else {
                    _.forEach(layerNeurons, function (layerNeuron, layerNeuronIndex, layerNeurons) {
                        if (!layerNeuron.fixed) {
                            layerNeuron.delta = m.chain(_.reduce(_.map(layerNeuron.outgoingConnections, function (synapse) {
                                return m.multiply(synapse.weight, synapse.outgoingConnection.delta);
                            }), function (accumulator, value) {
                                return m.add(accumulator, value);
                            }, m.bignumber(0))).multiply(layerNeuron.output).multiply(m.subtract(m.bignumber(1), layerNeuron.output)).done();
                        }
                    });
                }
            }
        }.bind(this));
    },

    calculateWeights: function calculateWeights(learningRate, momentumRate) {
        _.forEach(this.dataRepository.neuronLayers, function (neuronLayer, neuronLayerIndex, neuronLayers) {
            if (neuronLayerIndex > 0) {
                var layerNeurons = neuronLayers[neuronLayerIndex];
                _.forEach(layerNeurons, function (layerNeuron, layerNeuronIndex, layerNeurons) {
                    if (!layerNeuron.fixed) {
                        _.forEach(layerNeuron.incomingConnections, function (synapse, synapseIndex, synapses) {
                            synapse.previousWeightChange = synapse.weightChange;
                            synapse.weightChange = m.add(m.multiply(m.bignumber(learningRate), m.multiply(layerNeuron.delta, synapse.incomingConnection.output)), m.multiply(m.bignumber(momentumRate), synapse.previousWeightChange));
                            synapse.previousWeight = synapse.weight;
                            synapse.weight = m.add(synapse.weight, synapse.weightChange);
                        });
                    }
                });
            }
        });
    },

    train: function train(trainingPatterns, epochCallback, iterationCallback) {
        var trainingStatus = {
            outputErrors: [],
            interruptionRequest: false,
            elapsedEpochCounter: 0,
            elapsedIterationCounter: 0,
            elapsedIterationPattern: {
                input: [],
                output: [],
                error: []
            }
        };
        do {
            trainingStatus.outputErrors = [];
            trainingStatus.interruptionRequest = true;
            trainingStatus.elapsedIterationCounter = 0;
            trainingStatus = _.reduce(trainingPatterns, function (trainingStatus, trainingPattern) {
                this.setInputPattern(trainingPattern.input);
                this.setExpectedOutputPattern(trainingPattern.output);
                this.calculateActivations();
                this.calculateDeltas();
                this.calculateWeights(this.configuration.learningRate, this.configuration.momentumRate);
                var outputError = this.getOutputError();
                trainingStatus.outputErrors.push(outputError);
                trainingStatus.interruptionRequest = trainingStatus.interruptionRequest && m.smallerEq(outputError, m.bignumber(this.configuration.maximumError));
                trainingStatus.elapsedIterationCounter++;
                trainingStatus.elapsedIterationPattern.input = trainingPattern.input;
                trainingStatus.elapsedIterationPattern.target = this.getExpectedOutputPattern();
                trainingStatus.elapsedIterationPattern.output = this.getOutputPattern();
                trainingStatus.elapsedIterationPattern.error = outputError;
                if (iterationCallback) {
                    iterationCallback(trainingStatus);
                }
                return trainingStatus;
            }.bind(this), trainingStatus);
            trainingStatus.elapsedEpochCounter++;
            if (epochCallback) {
                epochCallback(trainingStatus);
            }
        } while (this.configuration.learningMode === "continuous" && !trainingStatus.interruptionRequest && trainingStatus.elapsedEpochCounter < this.configuration.maximumEpoch);
    },

    query: function query(inputPatterns, epochCallback, iterationCallback) {
        var queryingStatus = {
            outputPatterns: [],
            elapsedIterationCounter: 0,
            elapsedIterationPattern: {
                input: [],
                output: []
            }
        };
        _.forEach(inputPatterns, function (inputPattern) {
            this.setInputPattern(inputPattern);
            this.calculateActivations();
            var outputPattern = this.getOutputPattern();
            queryingStatus.outputPatterns.push(outputPattern);
            queryingStatus.elapsedIterationCounter++;
            queryingStatus.elapsedIterationPattern.input = inputPattern;
            queryingStatus.elapsedIterationPattern.output = outputPattern;
            if (iterationCallback) {
                iterationCallback(queryingStatus);
            }
        }.bind(this));
        if (epochCallback) {
            epochCallback(queryingStatus);
        }
    }
};

exports.NetworkAlpha = NetworkAlpha;
